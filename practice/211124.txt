★수업내용
파일명 : keras03_mlp1.py
파일명 : keras03_shape.py
★ numpy를 통한 배열의 이해
훈련전엔 백지이므로(가중치가 아무것도 없으므로) 첫 입력은 랜덤하게 준다

batch size 1이다=? x에 1을 넣어줬어.

결과값의 거리 차이는 양수니까 음수 나오면 절대값 or 양수로 바꿔줘야겠지?

batch size를 하나씩 넣어서 훈련량이 많아지는 거 vs batch를 [1, 2, 3] 통짜로 넣어서 훈련 한 턴에 끝내는 것
대신 속도, 과적합 문제

x   : 1, 2, 3, 4, 5
y1 : 173654, 2, -576, 1543, -27
y2 : 2, 4, Nan, 8, 10       <-weight=2
Nan = 결측치

데이터의 유형을 알고 있다??
· 결측치 처리의 6가지 방법 中
 -결측치에 0 넣기
 -열 자체를 삭제하기

무조건 데이터에 맞춰서 그래프를 긋는게 답은아님 ( 데이터가 과적합 될 수 있어 )
차라리 1차함수를 그리고서 버릴놈은 버리며 평가지표를 떨어뜨리는 편이 나을 수 있어.
y1의 이상치인 173654(아웃라이어)를 삭제하여 데이터가 모델에 적합하게 '전처리'한다

#1. 데이터
#2. 모델
#3. 훈련
#4. 예측

중 #1과정에서 전처리를 잘 해야 하겠다. (모델에서 처리되기 이전이라 전처리라함)

MSE가 작으면 좋을 것(이유?)

인터넷 보고 정리해 두기
3제곱인 9  +  -2제곱인 4  = 13   /2  = 6.5 (작을수록 GOOD)
시그마 (y-y예측치)^2

통상적으로 rmse를 가장 많이 사용한다

★ 컬럼/ 피처/ 특성/ 열 ★

input_dim = 1   (← 컬럼의 개수)
컬럼이 늘어남에 따라 input도 늘어나게 된다
지표로 보고 판단(mse rmse가 0에 가까우면 좋은 결과치겠지??)
output도 2개로 잡아준다

model.compile(loss='mse', optimizer='adam') # mse로 최소의 loss값을 찾겠다. mean squad error 작으면 good / loss를 부드럽게 만드는 optimizer
model.fit(x, y, epochs=100, batch_size=1)   # epochs로 n번의 선을 그어 훈련시키겠다. batch_size는 x와y를 한번에 다 집어 넣는게 아닌, 한게씩 집어 넣는게 훈련 잘 됨(1개씩 넣겠단 말) #batch가 작을수록 훈련이 잘 되지만 표본이 너무 많으면 힘들 수 있다(속도)

	평수	역거리		집값        (열)
1
2
3
4
5
(행)
	107	15		???

평수 , 역거리의 x 요소개수 = 인풋 개수
평수 역거리의 결과치 107,15 통해 ??? 예측치 예상


x = [1,2,3]   ←(3, )
y = [1,2,3]
1,2,3 각각은 스칼라이고,
x.y는 각각 스칼라 세개짜리 모임의 벡터 하나임

3행 1열이란? [[1], [2], [3]]
1행 3열이란? [[1, 2, 3]]

n=(1,2,3,4,,5,6,7,8,9,10)
스칼라 열개짜리 벡터한개

input_dim=1 이면 벡터가 하나라고.



0차원_스칼라  1차원_벡터 - 2차원_행렬(matrix) - 3차원_텐서 - 4차원_텐서 - 5차원_텐서 ....n차원_텐서...

꺾쇄가 3개다 차원이 3개다

문제

1. [[1,2],[3,4],[5,6]]
나 : 3행 2열

1 2
3 4
5 6

2. [[1,2,3],[4,5,6]]
나 : 2행 3열

1 2 3
4 5 6

3. [[[1],[2],[3]], [[4],[5],[6]]]
나 : 3행 1열 2축

(1축)
1
2
3
(2축)
1
2
3


4. [[[1,2], [3,4]], [[5,6], [7,8]]]
나 : 2행 2열 2축

(1축)
1 2
3 4
(2축)
5 6
7 8

5. [[[1,2,3], [4,5,6]]]
나 : 2행 3열 1축

(1축)
1 2 3
4 5 6

6. [1, 2, 3, 4, 5]
나 : (5, )

5


print(n.shape) 를 자주 쓰게 된다.



★ numpy를 통한 배열 구조의 변경
1. 행렬의 행,열 변환
3가지 reshape, transpose, swapaxes

이중 reshape는 분석의 전반에 있어서 많이 쓰지만
열과 행을 바꾸는 이번에 사용하지 않은 이유는 앞에서부터 순서대로 2쌍씩 잡아 버려서
(데이터의 순서가 바뀌지않음)

하지만 transpose는 데이터의 순서가 바뀜(가로와 세로가 바뀌어 버림)




우리가 지금까지 공부한 건
evaluate 해서 loss를 반환하는데 loss가 정확하지 않을 수 밖에..
predict도 예측가능한 값을 줬음

이구간은 훈련, 이구간은 평가할거야.
네 객관적인 loss값을 내게 보여줘 !
새로운값을 평가할 수없이 과적합이 되니까 예를들어 7개는 훈련시키고 3개는 평가에만 쓰겠다는 식으로 전체데이터를 갈라준다
예를들어 70퍼는 x.fit에서 사용, 30퍼는 model.evaluate 에서 사용ㄱㄱ





시퀀스 오브젝트 model에 노드를 Dense레이어를 통해 연결해줍니다
Dense 레이어는 입력과 출력을 모두 연결해주며 입력과 출력을 각각 연결해주는 가중치를 포함하고 있습니다.









★★★★
predict값은 임의의 값을 넣지만
어찌되었든 우리는 주어진 것 다음의 값을 보통 예측하려 하며
range가 주어진 경우 그 근사치를 구하고자 한다.
★★★★
공부를 하면서 소스코드를 이해하고 어느 부분을 고쳐야 최적의 결과를 얻을 수 있을지 확인하며
실제 히든레이어도 어떻게 고치면 좋은 결과를 낼지도 공부가 필요하겠다.